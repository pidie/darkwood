---
id: 9x3kjr34
title: Physics System
file_version: 1.1.3
app_version: 1.18.8
---

# TODO

*   Create and implement the `IPhysicsInteractable`<swm-token data-swm-token=":Assets/Scripts/Physics_/IPhysicsInteractable.cs:3:5:5:`    public interface IPhysicsInteractable`"/> interface

    *   Scripts that use physics will implement this instead of using a cookie cutter `PhysicsController`<swm-token data-swm-token=":Assets/Scripts/Physics_/PhysicsController.cs:6:5:5:`    public class PhysicsController : MonoBehaviour`"/>

    *   Retire the `PhysicsController`<swm-token data-swm-token=":Assets/Scripts/Physics_/PhysicsController.cs:6:5:5:`    public class PhysicsController : MonoBehaviour`"/> script

    *   Create a default implementation of `IPhysicsInteractable`<swm-token data-swm-token=":Assets/Scripts/Physics_/IPhysicsInteractable.cs:3:5:5:`    public interface IPhysicsInteractable`"/> to replace PhysicsController

    *   Potentially create modular physics behaviors and a drag-and-drop system within the inspector to control how the object behaves in real-time via scriptable objects

*   Define a global constant for gravity to be cached in the physics manager on Awake

    *   Have physics objects inherit gravity from the physics manager

* * *

# Overview

The Physics System is a suite of scripts that create and manage artificial gravity in the game. A custom physics system was preferred over Unity's built-in system for two main reasons:

1.  More refined control over how physics interacts with other game objects in the scene. It is much easier to create modular tools that can be repurposed for other uses later on (i,e.: `BobInPlace`<swm-token data-swm-token=":Assets/Scripts/Physics_/BobInPlace.cs:6:5:5:`    public class BobInPlace : MonoBehaviour`"/>).

2.  To the best of my knowledge, it is far easier to use a custom physics engine when working with a CharacterController component, as opposed to using both a Collider and Rigidbody component and managing them separately.

<br/>

The Physics Manager is pretty simple, but very effective.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ Assets/Scripts/Physics_/PhysicsManager.cs
```c#
11             public Action OnApplyPhysics;
12     
13             private void FixedUpdate() => OnApplyPhysics?.Invoke();
```

<br/>

Each object that interacts with physics has a physics controller component that tells it how to behave with gravity.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ Assets/Scripts/Physics_/PhysicsController.cs
```c#
25             // private void OnEnable() => PhysicsManager.OnApplyGravitationalForce += ApplyGravitationalForce;
26             //
27             // private void OnDisable() => PhysicsManager.OnApplyGravitationalForce -= ApplyGravitationalForce;
```

<br/>

It's important to know when to stop applying gravity to a game object.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ Assets/Scripts/Physics_/GroundCheck.cs
```c#
22             public bool CheckIsGrounded() => usePoint 
23                 ? Physics.CheckSphere(checker.position, radius, layerMask) 
24                 : Physics.CheckBox(checker.position, box, transform.rotation, layerMask);
```

<br/>

<br/>

* * *

# The Right Tool For the Job

Creating tools that utilize custom physics is super easy. To access the physics system, a script only needs to subscribe to the `OnApplyPhysics`<swm-token data-swm-token=":Assets/Scripts/Physics_/PhysicsManager.cs:12:5:5:`        public Action OnApplyPhysics;`"/> action. From there, it's as simple as defining the behavior associated with the subscription.

<br/>

This file was generated by Swimm. [Click here to view it in the app](https://app.swimm.io/repos/Z2l0aHViJTNBJTNBZGFya3dvb2QlM0ElM0FwaWRpZQ==/docs/9x3kjr34).
